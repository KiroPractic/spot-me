@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="@ContainerClass" @ref="_scrollContainer" id="@($"infinite-scroll-{_instanceId}")">
    @ChildContent
    
    @if (IsLoading)
    {
        <div class="infinite-scroll-loading">
            @if (LoadingTemplate != null)
            {
                @LoadingTemplate
            }
            else
            {
                <div class="spinner-border spinner-border-sm text-light" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <span class="ms-2">Loading...</span>
            }
        </div>
    }
</div>

@code {
    private ElementReference _scrollContainer;
    private DotNetObjectReference<InfiniteScroll>? _dotNetRef;
    private bool _initialized;
    private readonly string _instanceId = Guid.NewGuid().ToString("N");
    
    /// <summary>
    /// The content to display inside the infinite scroll container.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    
    /// <summary>
    /// Gets or sets the CSS class for the container div.
    /// </summary>
    [Parameter]
    public string ContainerClass { get; set; } = "";
    
    /// <summary>
    /// Template to show while loading more items.
    /// </summary>
    [Parameter]
    public RenderFragment? LoadingTemplate { get; set; }
    
    /// <summary>
    /// Callback to invoke when loading more items is needed.
    /// </summary>
    [Parameter]
    public EventCallback OnScroll { get; set; }
    
    /// <summary>
    /// Gets or sets whether the component is currently loading.
    /// </summary>
    [Parameter]
    public bool IsLoading { get; set; }
    
    /// <summary>
    /// Percentage of scroll (0-100) at which to trigger loading more content. Default is 80%.
    /// </summary>
    [Parameter]
    public int ScrollPercentage { get; set; } = 80;
    
    /// <summary>
    /// Whether to limit initial loading to one batch. Default is true.
    /// </summary>
    [Parameter]
    public bool LimitInitialLoad { get; set; } = true;
    
    protected override void OnInitialized()
    {
        _dotNetRef = DotNetObjectReference.Create(this);
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Delay initialization to ensure DOM is ready
            await Task.Delay(300);
            
            try
            {
                // Initialize scroll handling with the container's ID (more reliable than element reference)
                await JSRuntime.InvokeVoidAsync("setupInfiniteScroll",
                    $"infinite-scroll-{_instanceId}",
                    _dotNetRef,
                    ScrollPercentage,
                    LimitInitialLoad);
                    
                _initialized = true;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing infinite scroll: {ex.Message}");
            }
        }
    }
    
    [JSInvokable]
    public async Task LoadMoreItems()
    {
        if (!IsLoading)
        {
            await OnScroll.InvokeAsync();
        }
    }
    
    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_initialized)
            {
                await JSRuntime.InvokeVoidAsync("cleanupInfiniteScroll", $"infinite-scroll-{_instanceId}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error disposing InfiniteScroll: {ex.Message}");
        }
        finally
        {
            _dotNetRef?.Dispose();
            _dotNetRef = null;
        }
    }
}

<style>
    .infinite-scroll-loading {
        padding: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
    }
</style>